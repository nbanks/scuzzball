 Uses Crt;
 Const Black=0;
       Red=1;
       BlackKing=2;
       RedKing=3;
       Blank=$FF;

       CursorColour=2;
       GoodMoveColour=1;
 Type CharColour=
      Record
        Ch:Char;
        Co:Byte;
      End;
      BoardType=Array[0..63] of Byte;
      MoveType=Array[0..4] of Byte;
        {It is impossible to have more than four possible moves.}
 Var Screen:Array[0..24,0..79] of CharColour Absolute $B800:$0000;
     Board,PieceMap:BoardType;
     {Board has Blank,Red,Black,RedKing,BlackKing, but PieceMap indexes
      BlackPieces and RedPieces, with undefined blanks.}
     BlackPieces,RedPieces:Array[0..11] of Byte; {Ends at LastBlack/LastRed}
     LastBlack,LastRed,CurMove:Byte;
 Procedure DrawBoard;
  Const Piece:Array[0..2,0..5] of Char=
              ('  ‹‹  ',
               ' ﬁ€€› ',
               '  ﬂﬂ  ');
  var X,Y,SubX,SubY:Byte;
      Colour:Byte;
 Begin
   For Y:=0 to 7 do
     For X:=0 to 7 do
     Begin
       If (Y Xor X) And 1=0 then {The colour is red.}
         Colour:=$44 {Red on Red}
       Else
         Case Board[Y SHL 3+X] of
           Black:Colour:=$07; {Grey on Black}
           Red:Colour:=$04; {Red on Black}
           BlackKing:Colour:=$0F; {White on Black}
           RedKing:Colour:=$0C; {Bright red on Black}
         Else
           Colour:=$00;
         End;
       For SubY:=0 to 2 do
         For SubX:=0 to 5 do
           With Screen[Y*3+SubY,X*6+SubX+16] do
           Begin
             Co:=Colour;
             Ch:=Piece[SubY,SubX];
           End;
     End;
 End;
 Procedure RedoPieces;
  var Pos:Byte;
 Begin
   LastRed:=$FF;
   LastBlack:=$FF;
   For Pos:=0 to 63 do
     If Board[Pos]<>Blank then
       If Board[Pos] and 1=Red then
       Begin
         Inc(LastRed);
         RedPieces[LastRed]:=Pos;
         PieceMap[Pos]:=LastRed;
       End Else
       Begin
         Inc(LastBlack);
         BlackPieces[LastBlack]:=Pos;
         PieceMap[Pos]:=LastBlack;
       End;
 End;
 Procedure NewGame;
  var X,Y,Pos:Byte;
 Begin
   FillChar(Screen,SizeOf(Screen),$11);
   FillChar(Board,SizeOf(Board),Blank);
   For Y:=0 to 2 do
     For X:=0 to 3 do
     Begin
       Pos:=Y SHL 3+X SHL 1+Ord(Y And 1=0);
       Board[Pos]:=Black;
       PieceMap[Pos]:=Y SHL 2+X;
       BlackPieces[Y SHL 2+X]:=Pos;
     End;
   LastBlack:=11;
   For Y:=0 to 2 do
     For X:=0 to 3 do
     Begin
       Pos:=(Y+5) SHL 3+X SHL 1+Ord(Y And 1=1);
       Board[Pos]:=Red;
       PieceMap[Pos]:=Y SHL 2+X;
       RedPieces[Y SHL 2+X]:=Pos;
     End;
   LastRed:=11;

   Board[17]:=Black;
   CurMove:=Black;
   DrawBoard;
   GotoXY(80,25);
 End;
 Procedure FindValidMoves(Square:Byte; Var Moves:MoveType; Var Jump:Boolean);
  {This returns up to four possible moves for a square.  This is given in the
   form of a $FF terminated string.  If a jump is available, Jump is set.}
  var CurPos,CurGuy,MoveNum:Byte;
 Begin
   MoveNum:=0;
   Jump:=False;
   CurGuy:=Board[Square];
   Moves[0]:=$FF;
   If CurGuy=Blank then Exit;
   If CurGuy in[Black,BlackKing,RedKing] then
   Begin
     If (Square>55) and (CurGuy=Black) then
     Begin
       Moves[0]:=$FF;
       Exit;
     End;
     If Square and $7<>0 then
     Begin
       CurPos:=Square+7;
       If Board[CurPos]=Blank then
       Begin
         Moves[MoveNum]:=CurPos;
         Inc(MoveNum);
       End Else
         If Board[CurPos] and 1<>CurGuy and 1 then {Opposite side...}
         Begin
           CurPos:=CurPos+7;
           If (CurPos and $7<>7) and (Board[CurPos]=Blank) then
           Begin
             Moves[MoveNum]:=CurPos;
             Inc(MoveNum);
             Jump:=True;
           End;
       End;
     End;
     If Square and $7<>7 then
     Begin
       CurPos:=Square+9;
       If Board[CurPos]=Blank then
         If Not Jump then
         Begin
           Moves[MoveNum]:=CurPos;
           Inc(MoveNum);
         End Else
       Else
         If Board[CurPos] and 1<>CurGuy and 1 then {Opposite side.}
         Begin
           CurPos:=CurPos+9;
           If (CurPos and $7<>0) and (Board[CurPos]=Blank) then
           Begin
             If Not Jump then MoveNum:=0;
             Moves[MoveNum]:=CurPos;
             Inc(MoveNum);
             Jump:=True;
           End;
         End;
     End;
     Moves[MoveNum]:=$FF;
   End;
   If CurGuy in[Red,RedKing,BlackKing] then
   Begin
     If (Square<8) And (CurGuy=Red) then
     Begin
       Moves[0]:=$FF;
       Exit;
     End;
     If Square and $7<>7 then
     Begin
       CurPos:=Square-7;
       If Board[CurPos]=Blank then
         If Not Jump then
         Begin
           Moves[MoveNum]:=CurPos;
           Inc(MoveNum);
         End Else
       Else
         If Board[CurPos] and 1<>CurGuy and 1 then
         Begin
           CurPos:=CurPos-7;
           If (CurPos and $7<>0) and (Board[CurPos]=Blank) then
           Begin
             If Not Jump then MoveNum:=0;
             Moves[MoveNum]:=CurPos;
             Inc(MoveNum);
             Jump:=True;
           End;
         End;
     End;
     If Square and $7<>0 then
     Begin
       CurPos:=Square-9;
       If Board[CurPos]=Blank then
         If Not Jump then
         Begin
           Moves[MoveNum]:=CurPos;
           Inc(MoveNum);
         End Else
       Else
         If Board[CurPos] and 1<>CurGuy and 1 then
         Begin
           CurPos:=CurPos-9;
           If (CurPos and $7<>7) and (Board[CurPos]=Blank) then
           Begin
             If Not Jump then MoveNum:=0;
             Moves[MoveNum]:=CurPos;
             Inc(MoveNum);
             Jump:=True;
           End;
         End;
     End;
     Moves[MoveNum]:=$FF;
   End;
 End;
 Procedure GetMove;
  Procedure ChangeColour(X,Y,Colour:Byte);
   var CurX,CurY:Byte;
  Begin
    X:=X*6+16;
    Y:=Y*3;
    For CurY:=Y to Y+2 do
      For CurX:=X to X+5 do
        Screen[CurY,CurX].Co:=Colour;
  End;
  var OldColour,OldX,OldY:Byte;
  Procedure EraseOldSquare;
  Begin
    If OldX<>$FF Then
    Begin
      ChangeColour(OldX,OldY,OldColour);
      OldX:=$FF;
    End;
  End;
  Procedure SelectSquare(X,Y:Byte);
   {X,Y is from (0..7,0..7)}
   var NewColour:Byte;
  Begin
    EraseOldSquare;
    OldColour:=Screen[Y*3,X*6+16].Co;
    If OldColour SHR 4=OldColour And $F then
      NewColour:=(CursorColour SHL 4) or CursorColour
    Else NewColour:=(OldColour and $0F) or (CursorColour SHL 4);
    ChangeColour(X,Y,NewColour);
    OldY:=Y;
    OldX:=X;
  End;
  Var X,Y,Pos,CurSelected,NewSpot,Temp:Byte;
      Moves:MoveType;
      CanJump,CanMove,Jump,DoubleJump,JumpMessage:Boolean;
  Procedure FindMoves;
   Var Pos:Byte;
       Moves:MoveType;
  Begin
    CanMove:=False;
    JumpMessage:=False;
    If CurMove=Black Then
      If LastBlack<>255 then
        For Pos:=0 to LastBlack do
        Begin
          FindValidMoves(BlackPieces[Pos],Moves,CanJump);
          If Moves[0]<>$FF then CanMove:=True;
          If CanJump then Break; {This is the end of the test.}
        End
      Else
    Else
      If LastRed<>255 then
        For Pos:=0 to LastRed do
        Begin
          FindValidMoves(RedPieces[Pos],Moves,CanJump);
          If Moves[0]<>$FF then CanMove:=True;
          If CanJump then Break; {This is the end of the test.}
        End;
  End;
 Begin
   X:=4;
   Y:=4;
   OldX:=8;
   OldY:=0;
   OldColour:=$11;
   CurSelected:=$FF;
   DoubleJump:=False;
   FindMoves;
   Repeat
     SelectSquare(X,Y);
     TextAttr:=$17;
     GotoXY(25,25);
     If CanMove then
       If JumpMessage then
         Write('You Must Jump.') {Only if he's tried.}
       Else
         If CurMove=Black then Write('White''s Move  ')
         Else Write('Red''s Move    ')
     Else
     Begin
       If CurMove=Black then Write('Red is the winner')
       Else Write('White is the winner');
       ReadKey;
       Exit;
     End;
     Case ReadKey of
       #0:Case ReadKey of
            'H':Y:=(Y-1) and $07;
            'P':Y:=(Y+1) and $07;
            'K':X:=(X-1) and $07;
            'M':X:=(X+1) and $07;
          End;
       ' ',#13:
       Begin
         EraseOldSquare;
         If CurSelected=$FF then
           If (Board[Y SHL 3+X] and 1=CurMove) Then
           Begin
             DrawBoard;
             CurSelected:=Y SHL 3+X;
             FindValidMoves((Y SHL 3) or X,Moves,Jump);
             If CanJump and Not Jump then
             Begin
               JumpMessage:=True;
               Moves[0]:=$FF;
               CurSelected:=$FF;
             End;
             For Pos:=0 to 3 do
             Begin
               Temp:=Moves[Pos];
               If Temp=$FF then Break;
               ChangeColour(Temp And 7,Temp SHR 3,
                 GoodMoveColour SHL 4+GoodMoveColour);
             End;
           End Else
         Else
         Begin
           NewSpot:=Y SHL 3+X;
           For Pos:=0 to 4 do
           Begin
             Temp:=Moves[Pos];
             If Temp=$FF then
             Begin
               If Not DoubleJump then
               Begin
                 CurSelected:=$FF;
                 DrawBoard;
               End Else JumpMessage:=True;
               Break;
             End;
             If Temp=NewSpot then
             Begin
               Board[NewSpot]:=Board[CurSelected];
               PieceMap[NewSpot]:=PieceMap[CurSelected]; {Update the indexes}
               If CurMove=Red then
                 RedPieces[PieceMap[CurSelected]]:=NewSpot
               Else
                 BlackPieces[PieceMap[CurSelected]]:=NewSpot;
               Board[CurSelected]:=Blank;
               If Jump then
               Begin
                 Temp:=(NewSpot+CurSelected) SHR 1;
                 Board[Temp]:=Blank;
                 If CurMove=Red then
                 Begin
                   BlackPieces[PieceMap[Temp]]:=BlackPieces[LastBlack];
                   PieceMap[BlackPieces[LastBlack]]:=PieceMap[Temp];
                   Dec(LastBlack);
                 End Else
                 Begin
                   RedPieces[PieceMap[Temp]]:=RedPieces[LastRed];
                   PieceMap[RedPieces[LastRed]]:=PieceMap[Temp];
                   Dec(LastRed);
                 End;
                 FindValidMoves(NewSpot,Moves,DoubleJump);
                 If DoubleJump then
                 Begin
                   DrawBoard;
                   CurSelected:=NewSpot;
                   For Pos:=0 to 3 do
                   Begin
                     Temp:=Moves[Pos];
                     If Temp=$FF then Break;
                     ChangeColour(Temp And 7,Temp SHR 3,
                       GoodMoveColour SHL 4+GoodMoveColour);
                   End;
                   Break;
                 End;
               End;
               If (NewSpot<8) and (Board[NewSpot]=Red) then
                 Board[NewSpot]:=RedKing;
               If (NewSpot>55) and (Board[NewSpot]=Black) then
                 Board[NewSpot]:=BlackKing;
               CurMove:=CurMove Xor 1;
               FindMoves;
             End;
           End;
         End;
       End;
       'W':
         If (LastBlack<11) And ((Y+X) And 1=1) then
         Begin
           Board[Y SHL 3+X]:=BlackKing;
           RedoPieces;
           EraseOldSquare;
           DrawBoard;
         End;
       'w':
         If (LastBlack<11) And ((Y+X) And 1=1)  then
         Begin
           Board[Y SHL 3+X]:=Black;
           RedoPieces;
           EraseOldSquare;
           DrawBoard;
         End;
       'R':
         If (LastRed<11) And ((Y+X) And 1=1)  then
         Begin
           Board[Y SHL 3+X]:=RedKing;
           RedoPieces;
           EraseOldSquare;
           DrawBoard;
         End;
       'r':
         If (LastRed<11) And ((Y+X) And 1=1)  then
         Begin
           Board[Y SHL 3+X]:=Red;
           RedoPieces;
           EraseOldSquare;
           DrawBoard;
         End;
       'E','e':
         If (Board[Y SHL 3+X]<>Blank) And ((Y+X) And 1=1) And
           (((Board[Y SHL 3+X] and 1=Red) And (LastRed>0)) or
            ((Board[Y SHL 3+X] and 1=Black) And (LastBlack>0))) Then
         Begin
           Board[Y SHL 3+X]:=Blank;
           RedoPieces;
           EraseOldSquare;
           DrawBoard;
         End;
       #27:Break;
     End;
   Until False;
 End;
Begin
  NewGame;
  GetMove;
End.